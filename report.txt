RELATÓRIO

1. Termo de compromisso

Os membros do grupo afirmam que todo o código desenvolvido para este
trabalho é de autoria própria.  Exceto pelo material listado no item 3
deste relatório, os membros do grupo afirmam não ter copiado
material da Internet nem obtiveram código de terceiros.

2. Membros do grupo e alocação de esforço

Preencha as linhas abaixo com o nome e o e-mail dos integrantes do
grupo.  Substitua XX pela contribuição de cada membro do grupo no
desenvolvimento do trabalho.

Nome <lmvsminerador123@ufmg.br> 50%
Nome <email@domain.br> XX%

3. Referências bibliográficas

. Linux Manual (i.e. $ man 3 exec)
. Livro Texto (Abraham Silberschatz & CO; Fundamentos de Sistemas Operacionais; Nona Edição)
. http://www.filepermissions.com/directory-permission/0666
. https://stackoverflow.com/questions/22092088/the-waitpid-parameters
. https://www.qnx.com/developers/docs/6.5.0SP1.update/com.qnx.doc.neutrino_lib_ref/e/execvp.html
. https://stackoverflow.com/questions/5514464/difference-between-pthread-and-fork-on-gnu-linux/8514943

4. Estruturas de dados

T1 -> N/A . Não foi necessário implementar nenhuma estrutura de dados.
      Segue a resposta para essa task :

      O if verifica se no diretório atual existe uma pasta
      com o nome passado como parâmetro do comando cd. Caso não
      seja o caso, o shell imprime um erro e continua executando.

T2 -> Guarda-se na variável r o fork do processo a ser executado, ou
      seja, r guarda/é o filho do processo pai. 
      
      Caso r seja menor que 0, isso indica que houve um erro no 
      processo de criação do fork, logo uma mensagem de erro 
      customizada é printada junto à função perror() e esse system 
      call é terminado indicando erro (exit(1)).

      Caso r seja igual a 0 o processo de fork foi realizado com 
      sucesso. Nesse caso, executamos o comando que foi entrado
      no bash utilizando a função execvp() e armazenamos o inteiro
      de controle retornado por essa função em exe. Se exe for menor
      que 0 isso indica um erro - nesse caso, novamente, perror() é 
      chamado e a system call termina indicando erro.

      Para qualquer outro valor de r , suspenda suspender a 
      execução do thread de chamada até que um de seus filhos termine.
      Isso é feito utilizando a função waitpid() que tem como parâmetros :

      . O processo ao qual estou esperando, no caso r.
      . Um ponteiro para o inteiro que armazenará o status de saída de r.
      . O inteiro 0, indicando que não serão utilizadas flags/options.

      Por fim, o comando guardado em redircmd->cmd é executado.

T3 -> Em primeiro lugar, fecha-se o file descriptor apontado por
      redircmd->fd, de forma a evitar o mismatch de input ou
      output de comandos.

      Em seguida, cria-se um inteiro que armazenará o retorno da função
      open(). Como parâmetros dela foram utilizados :
      
      . O arquivo de entrada ou saída (um ponteiro para o arquivo),
        o qual é armazenado na estrutura redircmd->file ;
      . O inteiro que representa as flags com as quais o arquivo deve
        ser aberto, o qual é armazenado em redircmd->mode ;
      . O mode_t com que o arquivo deve ser aberto, no caso 0666, que
        indica apenas as permissões de leitura e escrita no arquivo.

      Caso esse inteiro seja menor que 0 houve algum problema na
      hora de se abrir o arquivo (provavelmente ele não existe).
      Nesse caso, novamente uma função perror() é chamada e o system
      call termina sua execução indicando erro.

      Por fim, o comando guardado em redircmd->cmd é executado.

T4 -> ...

      Por fim, o comando guardado em redircmd->cmd é executado.
